<?php

declare(strict_types=1);

namespace Chiron\View;

use Throwable;

// TODO : ajouter une méthode $this->escape() et $this->e() dans cette classe au lieu d'utiliser une fonction globale e() ????
//https://github.com/thephpleague/plates/blob/v3/src/Template/Template.php#L359

// https://github.com/yiisoft/view/blob/c81f3b910528dcefa3f02ef8a118da4fe16df218/src/WebView.php#L47
//https://github.com/cakephp/cakephp/blob/4.x/src/View/View.php


/**
 * View, the V in the MVC triad. View interacts with Helpers and view variables passed
 * in from the controller to render the results of the controller action. Often this is HTML,
 * but can also take the form of JSON, XML, PDF's or streaming files.
 *
 * CakePHP uses a two-step-view pattern. This means that the template content is rendered first,
 * and then inserted into the selected layout. This also means you can pass data from the template to the
 * layout using `$this->set()`
 *
 * View class supports using plugins as themes. You can set
 *
 * ```
 * public function beforeRender(\Cake\Event\EventInterface $event)
 * {
 *      $this->viewBuilder()->setTheme('SuperHot');
 * }
 * ```
 *
 * in your Controller to use plugin `SuperHot` as a theme. Eg. If current action
 * is PostsController::index() then View class will look for template file
 * `plugins/SuperHot/templates/Posts/index.php`. If a theme template
 * is not found for the current action the default app template file is used.
 *
 * @property \Cake\View\Helper\BreadcrumbsHelper $Breadcrumbs
 * @property \Cake\View\Helper\FlashHelper $Flash
 * @property \Cake\View\Helper\FormHelper $Form
 * @property \Cake\View\Helper\HtmlHelper $Html
 * @property \Cake\View\Helper\NumberHelper $Number
 * @property \Cake\View\Helper\PaginatorHelper $Paginator
 * @property \Cake\View\Helper\TextHelper $Text
 * @property \Cake\View\Helper\TimeHelper $Time
 * @property \Cake\View\Helper\UrlHelper $Url
 * @property \Cake\View\ViewBlock $Blocks
 */
final class ViewContext
{
    private array $blocks;

    /**
     * An array of names of built-in helpers to include.
     *
     * @var array
     */
    protected $helpers = [];

    // TODO : il faut surement faire étendre cette classe ViewContext de la classe Helper pour accéder au 2 helpers ci dessous !!!!
    public function __construct()
    {
        $this->helpers['Url']['class'] = \Chiron\View\Helper\UrlHelper::class;
        $this->helpers['Html']['class'] = \Chiron\View\Helper\HtmlHelper::class;
    }

    /**
     * Magic accessor for helpers.
     *
     * @param string $name Name of the attribute to get.
     * @return \Cake\View\Helper|null
     */
    public function __get(string $name)
    {
        if (isset($this->helpers[$name]) && !isset($this->{$name})) {
            $this->{$name} = new $this->helpers[$name]['class']();

            return $this->{$name};
        }
    }

    /**
     * It processes the CSS configuration generated by the asset manager and converts it into HTML code.
     *
     * @param array $cssFiles
     */
    public function addCssFiles(array $cssFiles): void
    {
        /** @var mixed $value */
        foreach ($cssFiles as $key => $value) {
            $this->registerCssFileByConfig(
                is_string($key) ? $key : null,
                is_array($value) ? $value : [$value],
            );
        }
    }

    /**
     * @throws InvalidArgumentException
     */
    private function registerCssFileByConfig(?string $key, array $config): void
    {
        if (!array_key_exists(0, $config)) {
            throw new InvalidArgumentException('Do not set CSS file.');
        }
        $file = $config[0];

        if (!is_string($file)) {
            throw new InvalidArgumentException(
                sprintf(
                    'CSS file should be string. Got %s.',
                    get_debug_type($file),
                )
            );
        }

        unset($config[0], $config[1]); // TODO : virer le $config[1] car ca ne sert à rien on n'a pas d'index à 1 dans le tableau !!!!
        $this->registerCssFile($file, $config, $key);
    }

    /**
     * Registers a CSS file.
     *
     * This method should be used for simple registration of CSS files. If you want to use features of
     * {@see \Yiisoft\Assets\AssetManager} like appending timestamps to the URL and file publishing options, use
     * {@see \Yiisoft\Assets\AssetBundle}.
     *
     * @param string $url The CSS file to be registered.
     * @param array $options the HTML attributes for the link tag. Please refer to {@see \Yiisoft\Html\Html::cssFile()}
     * for the supported options.
     * @param string|null $key The key that identifies the CSS script file. If null, it will use $url as the key.
     * If two CSS files are registered with the same key, the latter will overwrite the former.
     */
    // TODO : virer le paramétre $key
    public function registerCssFile(
        string $url,
        array $options = [],
        string $key = null
    ): void {
        $this->assign('css', $this->Html->css($url, $options), append: true);
    }

    /**
     * It processes the JS configuration generated by the asset manager and converts it into HTML code.
     *
     * @param array $jsFiles
     */
    public function addJsFiles(array $jsFiles): void
    {
        /** @var mixed $value */
        foreach ($jsFiles as $key => $value) {
            $this->registerJsFileByConfig(
                is_string($key) ? $key : null,
                is_array($value) ? $value : [$value],
            );
        }
    }

    /**
     * @throws InvalidArgumentException
     */
    private function registerJsFileByConfig(?string $key, array $config): void
    {
        if (!array_key_exists(0, $config)) {
            throw new InvalidArgumentException('Do not set JS file.');
        }
        $file = $config[0];

        if (!is_string($file)) {
            throw new InvalidArgumentException(
                sprintf(
                    'JS file should be string. Got %s.',
                    get_debug_type($file),
                )
            );
        }

        unset($config[0], $config[1]); // TODO : virer le $config[1] car ca ne sert à rien on n'a pas d'index à 1 dans le tableau !!!!
        $this->registerJsFile($file, $config, $key);
    }

    /**
     * Registers a JS file.
     *
     * This method should be used for simple registration of JS files. If you want to use features of
     * {@see \Yiisoft\Assets\AssetManager} like appending timestamps to the URL and file publishing options, use
     * {@see \Yiisoft\Assets\AssetBundle}.
     *
     * @param string $url The JS file to be registered.
     * @param array $options The HTML attributes for the script tag. The following options are specially handled and
     * are not treated as HTML attributes:
     *
     * - `position`: specifies where the JS script tag should be inserted in a page. The possible values are:
     *     * {@see WebView::POSITION_HEAD}: in the head section
     *     * {@see WebView::POSITION_BEGIN}: at the beginning of the body section
     *     * {@see WebView::POSITION_END}: at the end of the body section. This is the default value.
     *
     * Please refer to {@see \Yiisoft\Html\Html::javaScriptFile()} for other supported options.
     * @param string|null $key The key that identifies the JS script file. If null, it will use $url as the key.
     * If two JS files are registered with the same key at the same position, the latter will overwrite the former.
     * Note that position option takes precedence, thus files registered with the same key, but different
     * position option will not override each other.
     */
    // TODO : virer le paramétre $key
    public function registerJsFile(
        string $url,
        array $options = [],
        string $key = null
    ): void {
        $this->assign('script', $this->Html->script($url, $options), append: true);
    }

    /**
     * Set the content for a block. This will overwrite any
     * existing content.
     *
     * @param string $name Name of the block
     * @param string $value The content for the block.
     * @param bool $append Concatenate the content with existing data.
     *
     */
    // TODO : faire un return $this pour chainer les appels ????
    public function assign(string $name, string $value, bool $append = false): void
    {
        if (!isset($this->blocks[$name])) {
            $this->blocks[$name] = '';
        }

        if ($append === false) {
            $this->blocks[$name] = $value;
        } else {
            $this->blocks[$name] .= $value;
        }
    }

    /**
     * Fetch the content for a block. If a block is
     * empty or undefined '' will be returned.
     *
     * @param string $name Name of the block
     * @param string $default Default text
     * @return string The block content or $default if the block does not exist.
     * @see \Cake\View\ViewBlock::get()
     */
    // TODO : Créer une méthode proxy dans la classe View pour récupérer ces informations histoire de pouvoir les utiliser dans les controllers par exemple
    public function fetch(string $name, string $default = ''): string
    {
        return $this->blocks[$name] ?? $default;
    }

    /**
     * Check if a block exists
     *
     * @param string $name Name of the block
     * @return bool
     */
    // TODO : si on garde cette méthode il faudra créer une méthode proxy dans la classe View pour récupérer ces informations histoire de pouvoir les utiliser dans les controllers par exemple
    /*
    public function exists(string $name): bool
    {
        return isset($this->blocks[$name]);
    }*/

    /**
     * Get the names of all the existing blocks.
     *
     * @return array<string> An array containing the blocks.
     */
    // TODO : si on garde cette méthode il faudra créer une méthode proxy dans la classe View pour récupérer ces informations histoire de pouvoir les utiliser dans les controllers par exemple
    /*
    public function keys(): array
    {
        return array_keys($this->blocks);
    }*/
}
